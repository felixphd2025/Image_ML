import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D
from tensorflow.keras.preprocessing import image

def main():
    # Create the Streamlit app
    st.title("Visualizing Conv2D Kernels and Feature Maps")

    # Input kernel number for model to use
    st.write("Input the number of kernels you want to visualize")
    num_kernels = st.number_input("Number of kernels", min_value=1, max_value=64, value=32, step=1)

    # Create a model with Conv2D and MaxPooling2D layers
    model = Sequential([
        Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)),
        MaxPooling2D(2, 2),
        Conv2D(64, (3, 3), activation='relu'),
        MaxPooling2D(2, 2),
        Conv2D(128, (3, 3), activation='relu'),
        MaxPooling2D(2, 2)
    ])

    # Allow user to upload an image
    uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "jpeg", "png"])

    if uploaded_file is not None:
        # Load the image using the image module from Keras
        img = image.load_img(uploaded_file, target_size=(150, 150))
        st.image(img, caption="Uploaded Image", use_column_width=True)

        # Convert the image to a numpy array and expand dimensions to match model input
        img_array = image.img_to_array(img)
        img_array = np.expand_dims(img_array, axis=0)  # Adding batch dimension

        # Normalize the image
        img_array = img_array / 255.0  # Rescale pixel values to the range [0, 1]

        # Pass the image through the model to get the feature maps from the Conv2D and MaxPooling2D layers
        feature_maps = model.predict(img_array)

        # Show the kernels (filters) as images
        st.subheader("Visualizing the Kernels (Filters) Learned by Conv2D Layer")
        
        # Extract the kernels (filters) of the Conv2D layer
        kernels = model.layers[0].get_weights()[0]  # (3, 3, 3, num_kernels) shape for kernels

        # Plot the kernels in a 4x8 grid
        fig, axes = plt.subplots(4, 8, figsize=(15, 8))
        axes = axes.flatten()

        for i in range(num_kernels):
            ax = axes[i]
            # Extract the i-th kernel
            kernel = kernels[:, :, 0, i]

            # Display the kernel values as a heatmap with numbers
            ax.imshow(kernel, cmap='gray')  # Display the kernel image
            ax.axis('off')
            ax.set_title(f'Kernel {i + 1}')

        plt.tight_layout()
        st.pyplot(fig)

        # Display the feature maps after passing the image through the model
        st.subheader("Feature Maps Generated by Kernels for the Uploaded Image")
        
        # Feature maps after passing through the Conv2D layers (32 filters)
        fig, axes = plt.subplots(8, 8, figsize=(15, 15))  # 8x8 grid for up to 64 filters
        axes = axes.flatten()

        for i in range(32):
            ax = axes[i]
            feature_map = feature_maps[0, :, :, i]
            feature_map_min, feature_map_max = feature_map.min(), feature_map.max()
            feature_map_normalized = (feature_map - feature_map_min) / (feature_map_max - feature_map.min())
            ax.imshow(feature_map_normalized, cmap='viridis')
            ax.axis('off')

        plt.tight_layout()
        st.pyplot(fig)

        # Display the second set of feature maps (64 filters from second Conv2D layer)
        st.subheader("Feature Maps from the Second Conv2D Layer (64 Filters)")

        fig, axes = plt.subplots(8, 8, figsize=(15, 15))  # 8x8 grid for 64 filters
        axes = axes.flatten()

        for i in range(64):
            ax = axes[i]
            feature_map = feature_maps[0, :, :, i + 32]  # First 32 filters are already visualized
            feature_map_min, feature_map_max = feature_map.min(), feature_map.max()
            feature_map_normalized = (feature_map - feature_map_min) / (feature_map_max - feature_map.min())
            ax.imshow(feature_map_normalized, cmap='viridis')
            ax.axis('off')

        plt.tight_layout()
        st.pyplot(fig)

        # Display the third set of feature maps (128 filters from third Conv2D layer)
        st.subheader("Feature Maps from the Third Conv2D Layer (128 Filters)")

        fig, axes = plt.subplots(16, 8, figsize=(15, 20))  # 16x8 grid for 128 filters
        axes = axes.flatten()

        for i in range(128):  # 128 filters from the third layer
            ax = axes[i]
            feature_map = feature_maps[0, :, :, i]  # Accessing the feature map for 128 filters directly
            feature_map_min, feature_map_max = feature_map.min(), feature_map.max()
            feature_map_normalized = (feature_map - feature_map_min) / (feature_map_max - feature_map.min())
            ax.imshow(feature_map_normalized, cmap='viridis')
            ax.axis('off')

        plt.tight_layout()
        st.pyplot(fig)

if __name__ == "__main__":
    main()
